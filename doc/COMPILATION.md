## Compiling the firmware (HIDO)

This document describes the supported methods to compile the HIDO firmware on Windows (PowerShell). It also documents the legacy method of selecting the operating mode by commenting/uncommenting `#define` lines in the source.

### Requirements

- `arm-none-eabi-gcc` available in `PATH` (ARM GCC toolchain)
- `make` (optional — used by `build.ps1` when delegating to the Makefile)
- PowerShell (Windows). If script execution is restricted use `-ExecutionPolicy Bypass` when running the script.

If you don't have the ARM GCC toolchain, download it from: https://developer.arm.com/downloads/-/gnu-rm

---

## Method A — High-level wrapper `build.ps1`

Location: `firmware/build.ps1`

This script checks for the ARM GCC toolchain and, by default, invokes the project's `Makefile` to build. It accepts a `-Mode` parameter with values `keyboard`, `joystick` or `jvs`.

Examples (PowerShell, run from the repository root):

```powershell
# Build using the Makefile (requires arm-none-eabi-gcc and make)
.\firmware\build.ps1

# Build a specific mode (delegates to compile_direct.ps1)
.\firmware\build.ps1 -Mode joystick
```

Expected outputs after a successful build:
- `build/hido.elf` (ELF binary)
- `build/hido.hex` (Intel HEX)
- `build/hido.bin` (raw binary)

---

## Method B — Direct compilation `compile_direct.ps1` (no make required)

Location: `firmware/compile_direct.ps1`

This script invokes `arm-none-eabi-gcc` directly and accepts a `-Mode` parameter (default: `keyboard`). It produces the same output files inside the `build/` directory.

Usage examples:

```powershell
# From the repository root
.\firmware\compile_direct.ps1 -Mode joystick

# Or force execution bypassing policy
powershell -ExecutionPolicy Bypass -File .\firmware\compile_direct.ps1 -Mode jvs
```

Notes:
- The script will clean the `build/` directory before starting.
- The script passes a `-D` preprocessor define for the chosen mode (`-DUSE_JOYSTICK_MODE`, `-DUSE_KEYBOARD_MODE`, or `-DUSE_JVS_MODE`).

---

## Method C — STM32CubeIDE (GUI)

You can open and build the project directly from STM32CubeIDE. The repository contains an `.ioc` file (`firmware/hido.ioc`) which stores the MCU configuration and CubeMX settings.

Typical steps:

- Open `firmware/hido.ioc` with STM32CubeIDE (File → Open File or double-click the `.ioc` from the IDE). The project will be created or imported into the workspace.
- In the .ioc editor click **Generate Code** (if required) to create/update project sources.
- Build the project via **Project → Build Project** (or the hammer icon). STM32CubeIDE will use its configured toolchain (usually ARM GCC) to compile and link.
- To flash/debug use the ST-Link connection (Run → Debug or Run As → STM32 MCU C/C++ Application) or the IDE's built-in flasher.

Notes:

- STM32CubeIDE provides an integrated workflow (CubeMX + build + flash) which is convenient for iterative development and debugging.
- If the IDE uses a different toolchain installation, ensure `arm-none-eabi-gcc` is available or configured in the IDE settings.

Warning about regenerating code from the `.ioc` file:

- This project contains custom modifications to middleware and HID files (for example `firmware/Core/Src/usbd_hid_custom.c` and `firmware/Core/Inc/usbd_hid_custom.h`) that implement a custom dual-joystick HID descriptor and other overrides.
- Regenerating code from `firmware/hido.ioc` (CubeMX code generation) can overwrite these custom edits and break the firmware. Do NOT regenerate the project from the `.ioc` unless you know exactly which files CubeMX will overwrite.
- If you must regenerate: first back up `Core/Src/usbd_hid_custom.c`, `Core/Inc/usbd_hid_custom.h` and any other locally modified middleware files, run code generation, then re-apply your custom changes or merge them carefully.

Detected library information (from repository files):

- CMSIS Core(M): version V5.0.2 (see `firmware/Drivers/CMSIS/Include/cmsis_version.h`).
- STM32F1 HAL sources included (copyright headers show `2016-2017`) — these are the STM32F1 HAL driver sources in `firmware/Drivers/STM32F1xx_HAL_Driver/`.
- STM32 USB Device Library files in `firmware/Middlewares/ST/STM32_USB_Device_Library/` contain ST copyright headers dated `2015`.
- STM32CubeIDE autogenerated linker script shows a `2020` copyright in `firmware/STM32F102RBTX_FLASH.ld`.

If you want exact package versions used by STM32CubeIDE on your machine, open the `.ioc` in STM32CubeIDE and check the "Project Manager → Firmware Package" and the generated `MX` configuration (or the IDE's Help → About → Installed Software) — I can also try to detect additional metadata in repository files if you want.

---

## Legacy method — comment/uncomment the `#define` lines

Relevant file: `firmware/Core/Inc/usbd_hid_custom.h`

The legacy way to select the operating mode is to edit `usbd_hid_custom.h` and ensure that ONLY ONE of the following lines is uncommented:

```c
// #define USE_KEYBOARD_MODE    // NKRO Keyboard mode
// #define USE_JOYSTICK_MODE    // Arcade Joystick mode
// #define USE_JVS_MODE         // JVS protocol mode
```

For example, to build the joystick mode uncomment `#define USE_JOYSTICK_MODE` and comment the other two. After editing the header, run either Method A or Method B to rebuild.

---

## Recommendations and tips

- For reproducible builds prefer using the `-Mode` parameter of `build.ps1` or `compile_direct.ps1` rather than editing source files.
- If `make` is not installed, call `build.ps1 -Mode <mode>` — the script will delegate to `compile_direct.ps1`.
- To flash the device after building, see the DFU helper scripts in `firmware/` such as `dfu_update.py` or `dfu_update.bat`.

### Enable PowerShell scripts (convenience)

If your system blocks script execution, enable scripts for the current user with this PowerShell command (run once):

```powershell
Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned -Force
```

Alternatively run a single script without changing policy:

```powershell
powershell -ExecutionPolicy Bypass -File .\firmware\compile_direct.ps1 -Mode joystick
```

---

## DFU Mode (status)

DFU-related functionality and scripts in `firmware/` are currently a work in progress. The DFU mode and helper scripts are marked TODO and are not fully operational yet — do not rely on them for automated flashing until updated.

If you want, I can add example build outputs and step-by-step flashing commands (DFU or ST-Link) to this document.
